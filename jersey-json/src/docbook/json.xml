<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % ents SYSTEM "jersey.ent">
%ents;
]>
<chapter id="json">
  <title>JSON Support</title>

  <para>Jersey JSON support comes as a set of JAX-RS <ulink
  url="https://jsr311.dev.java.net/nonav/releases/&jsr311-version;/javax/ws/rs/ext/MessageBodyReader.html">MessageBodyReader</ulink>
  and <ulink
  url="https://jsr311.dev.java.net/nonav/releases/&jsr311-version;/javax/ws/rs/ext/MessageBodyWriter.html">MessageBodyWriter</ulink>
  providers distributed with <emphasis>jersey-json</emphasis> module. These providers enable using
  two basic approaches when working with JSON format:

  <itemizedlist>
    <listitem>
      <para><link linkend="json.jaxb.approach.title">JAXB based JSON support</link></para>
    </listitem>
    <listitem>
      <para><link linkend="json.low.level.approach.title">Low-level, JSONObject/JSONArray based JSON support</link></para>
    </listitem>
  </itemizedlist>
  
  Both approaches use the same principle. You need to make your resource methods consume and/or produce
  instances of certain Java types, known to provided MessageBodyReaders/Writers. Also, naturally, you need to make sure
  you use <emphasis>jersey-json</emphasis> module with your application.
  </para>

  <section>
    <title id="json.jaxb.approach.title">JAXB Based JSON support</title>
    
    <para>
     Taking this approach will save you a lot of time, if you want to easily produce/consume both JSON and XML data format.
     Because even then you will still be able to use a unified Java model. 
     Another advantage is simplicity of working with such a model, as JAXB leverages annotated POJOs and these could be handled
     as simple Java beans
    </para>
    <para>
     A disadvantage of JAXB based approach could be if you need to work with a very specific JSON format. Then it could be
     difficult to find a proper way to get such a format produced and consumed. This is a reason why a lot of configuration options
     are provided, so that you can control how things get serialized out and deserialized back.
    </para>
    
    <para>
    Following is a very simple example of how a JAXB bean could look like.
<example>
<title>Simple JAXB bean implementation</title>
<programlisting linenumbering="numbered">@XmlRootElement
public class MyJaxbBean {
  public String name;
  public int age;
      
  public MyJaxbBean() {} // JAXB needs this

  public MyJaxbBean(String name, int age) {
    this.name = name;
    this.age = age;
  }
}</programlisting>
</example>
    
    Using the above JAXB bean for producing JSON data format from you resource method, is then as simple as:
    
<example>
<title>JAXB bean used to generate JSON representation</title>
<programlisting linenumbering="numbered">@GET @Produces(<emphasis>"application/json"</emphasis>)
public <emphasis>MyJaxbBean</emphasis> getMyBean() {
   return <emphasis>new MyJaxbBean("Agamemnon", 32)</emphasis>;
}</programlisting>
</example>
    
    Notice, that JSON specific mime type is specified in @Produces annotation, and the method returns an instance
    of MyJaxbBean, which JAXB is able to process. Resulting JSON in this case would look like:
    
<programlisting>
    {"name":"Agamemnon", "age":"32"}
</programlisting>
    </para>
    
    <section>
    	<title>Configuration Options</title>
	
	<para>
	JAXB itself enables you to control output JSON format to certain extent. Specifically renaming 
	and ommiting items is easy to do directly using JAXB annotations.
	
	E.g. the following example depicts changes in the above mentioned MyJaxbBean that will result in <code>{"king":"Agamemnon"}</code> JSON output.
<example>
<title>Tweaking JSON format using JAXB</title>
<programlisting linenumbering="numbered">@XmlRootElement
public class MyJaxbBean {
  
    @XmlElement(name="king")
    public String name;
  
    @XmlTransient
    public int age;
 
    // several lines removed       
}</programlisting>
</example>
	</para>
	
	<para>
	To achieve more important JSON format changes, you will need to configure Jersey JSON procesor itself.
	Various configuration options could be set on  an
	<ulink url="https://jersey.dev.java.net/nonav/apidocs/&version;/jersey/com/sun/jersey/api/json/JSONConfiguration.html">JSONConfiguration</ulink>
	instance. The instance could be then further used to create a JSONConfigurated 
	<ulink url="https://jersey.dev.java.net/nonav/apidocs/&version;/jersey/com/sun/jersey/api/json/JSONJAXBContext.html">JSONJAXBContext</ulink>,
	which serves as a main configuration point in this area.
	To pass your specialized JSONJAXBContext to Jersey, you will finally need to implement 
	a JAXBContext <ulink url="https://jsr311.dev.java.net/nonav/releases/&jsr311-version;/javax/ws/rs/ext/ContextResolver.html">ContextResolver</ulink>
	</para>
	
	<example id="json.jaxb.context.resolver.example">
	<title>An example of a JAXBContext resolver implementation</title>
	<programlisting linenumbering="numbered">@Provider
public class JAXBContextResolver implements ContextResolver&lt;JAXBContext&gt; {

    private JAXBContext context;
    private Class[] types = {MyJaxbBean.class};

    public JAXBContextResolver() throws Exception {
        this.context = 
	  new JSONJAXBContext( <co id="json.ctx.resolver.init"/>
	    JSONConfiguration.natural().build(), types); <co id="json.ctx.resolver.config"/>
    }

    public JAXBContext getContext(Class&lt;?&gt; objectType) {
        for (Class type : types) {
            if (type == objectType) {
                return context;
            }
        }
        return null;
    }
}</programlisting>
	<calloutlist>
	 <callout arearefs="json.ctx.resolver.init">
	 	<para>Creation of our specialized JAXBContext</para> 
	</callout>
	 <callout arearefs="json.ctx.resolver.config">
	 	<para>Final JSON format is given by this JSONConfiguration instance</para> 
	</callout>
	</calloutlist>
	</example>
    </section>
    
    <section>
     <title>JSON Notations</title>
     <para>
      JSONConfiguration allows you to use four various JSON notations. Each of these notations serializes JSON in a different way.
      Following is a list of supported notations:

      <itemizedlist>
    <listitem>
      <para>MAPPED (default notation)</para>
    </listitem>
    <listitem>
      <para>NATURAL</para>
    </listitem>
    <listitem>
      <para>JETTISON_MAPPED</para>
    </listitem>
    <listitem>
      <para>BADGERFISH</para>
    </listitem>
  </itemizedlist>
      </para>
      
      <para>
      Individual notations and their further configuration options are described bellow. Rather then explaining rules for mapping
      XML constructs into JSON, the notations will be described using a simple example. Following are JAXB beans, which will be used.
      
      <example><title>JAXB beans for JSON supported notations description, simple address bean</title>
      <programlisting linenumbering="numbered">@XmlRootElement
public class Address {
    public String street;
    public String town;

    public Address(){}

    public Address(String street, String town) {
        this.street = street;
        this.town = town;
    }
}</programlisting>
      </example>

      <example><title>JAXB beans for JSON supported notations description, contact bean</title>
      <programlisting linenumbering="numbered">@XmlRootElement
public class Contact {

    public int id;
    public String name;
    public List&lt;Address&gt; addresses;

    public Contact() {};

    public Contact(int id, String name, List&lt;Address&gt; addresses) {
        this.name = name;
        this.id = id;
        this.addresses = 
	        (addresses != null) ? new LinkedList&lt;Address&gt;(addresses) : null;
    }
}</programlisting>
      </example>
      </para>
      
      <para>
      Following text will be mainly working with a contact bean initialized with:
      <example id="json.jaxb.bean.init.example"><title>JAXB beans for JSON supported notations description, initialization</title>
      <programlisting>final Address[] addresses = {new Address("Long Street 1", "Short Village")};
Contact contact = new Contact(2, "Bob", Arrays.asList(addresses));</programlisting>
</example>
I.e. contact bean with <code>id=2</code>, <code>name="Bob"</code> containing 
a single address (<code>street="Long Street 1"</code>, <code>town="Short Village"</code>).
      </para>
      
      <para>All bellow described configuration options are documented 
      also in apidocs at <ulink url="https://jersey.dev.java.net/nonav/apidocs/&version;/jersey/com/sun/jersey/api/json/JSONConfiguration.html"/>
      </para>
      
      
      
      
      <section>
       <title>Mapped notation</title>
       
       
       <para>
       <code>JSONConfiguration</code> based on <literal>mapped</literal> notation could be build with 
       <programlisting>JSONConfiguration.mapped().build()</programlisting>
       for usage in a <code>JAXBContext</code> resolver, <xref linkend="json.jaxb.context.resolver.example"/>.
       Then a contact bean initialized with <xref linkend="json.jaxb.bean.init.example"/>, will be serialized as
       <example><title>JSON expression produced using <literal>mapped</literal> notation</title>
       <programlisting linenumbering="numbered">{ "id":"2" 
 ,"name":"Bob"
 ,"addresses":{"street":"Long Street 1"
                    ,"town":"Short Village"}}</programlisting>
       </example>
       The JSON representation seems fine, and will be working flawlessly with Java based Jersey client API.
       </para>
       <para>
       However, at least one issue might appear once you start using it with a JavaScript based client.
       The information, that <code>addresses</code> item represents an array, is being lost for every single element array. 
       If you added another address bean to the contact,<programlisting>contact.addresses.add(new Address("Short Street 1000", "Long Village"));</programlisting>,
       you would get 
       <programlisting linenumbering="numbered">{ "id":"2" 
 ,"name":"Bob"
 ,"addresses":[{"street":"Long Street 1","town":"Short Village"}
              ,{"street":"Short Street 1000","town":"Long Village"}]}</programlisting>
        Both representations are correct, but you will not be able to consume them using a single JavaScript client,
	because to access <code>"Short Village"</code> value, you will write <code>addresses.town</code> in one
	case and <code>addresses[0].town</code> in the other.
	To fix this issue, you need to instruct the JSON processor, what items need to be treated as arrays
	by setting an optional property, <literal>arrays</literal>, on your <code>JSONConfiguration</code> object.
	For our case, you would do it with
       <example><title>Force arrays in <literal>mapped</literal> JSON notation</title>
       <programlisting>JSONConfiguration.mapped().arrays("addresses").build()</programlisting>
       </example>
       You can use multiple string values in the <literal>arrays</literal> method call, in case you are dealing with more
       than one array item in your beans. Similar mechanism (one or more argument values) applies also for all below desribed options.
       </para>
       
       <para>Another issue might be, that number value, <literal>2</literal>, for <code>id</code> item 
       gets written as a string, <literal>"2"</literal>. To avoid this, you can use another optional property on <code>JSONConfiguration</code>
       called <literal>nonStrings</literal>.
       <example><title>Force non-string values in <literal>mapped</literal> JSON notation</title>
       <programlisting>JSONConfiguration.mapped().arrays("addresses").nonStrings("id").build()</programlisting>
       </example>
	</para>       
       
       <para>
       It might happen you use XML attributes in your JAXB beans. In <literal>mapped</literal> JSON notation, these attribute names are prefixed with <literal>@</literal>
       character. If <code>id</code> was an attribute, itÂ´s definition would look like:
       <programlisting>  ...
  @XmlAttribute
  public int id;
  ...</programlisting>
       and then you would get <programlisting>{"@id":"2" ...</programlisting> at the JSON output.
       In case, you want to get rid of the <literal>@</literal> prefix, you can take advantage of another configuration 
       option of <literal>JSONConfiguration</literal>, called <literal>attributeAsElement</literal>.
       Usage is similar to previous options.
       <example><title>XML attributes as XML elements in <literal>mapped</literal> JSON notation</title>
       <programlisting>JSONConfiguration.mapped().attributeAsElement("id").build()</programlisting>
       </example>
       </para>
	<para>
	<literal>Mapped</literal> JSON notation was designed to produce the simplest possible JSON expression out of JAXB beans. While in XML,
	you must always have a root tag to start a XML document with, there is no such a constraint in JSON. If you wanted to be strict,
	you might have wanted to keep a XML root tag equivalent generated in your JSON. If that is the case, another configuration option
	is available for you, which is called <literal>rootUnwrapping</literal>. You can use it as follows:
       <example id="json.jaxb.mapped.root.unwrapping"><title>Keep XML root tag equivalent in JSON <literal>mapped</literal> JSON notation</title>
       <programlisting>JSONConfiguration.mapped().rootUnwrapping(false).build()</programlisting>
       </example>
       and get the following JSON for our <literal>Contact</literal> bean:
       <example><title>XML root tag equivalent kept in JSON using <literal>mapped</literal> notation</title>
       <programlisting linenumbering="numbered">{"contact":{ "id":"2" 
 ,"name":"Bob"
 ,"addresses":{"street":"Long Street 1"
                    ,"town":"Short Village"}}}</programlisting>
       </example>
	<literal>rootUnwrapping</literal> option is set to <literal>true</literal> by default. You should switch it to <literal>false</literal>
	if you use inheritance at your JAXB beans. Then JAXB might try to encode type information into root element names, and by stripping these
	elements off, you could break unmarshalling.
	</para>
	
	<para>
	In version 1.1.1-ea, XML namespace support was added to the MAPPED JSON notation. There is of course no such thing as XML namespaces in JSON,
	but when working from JAXB, XML infoset is used as an intermediary format. And then when various XML namespaces are used, ceratin information 
	related to the concrete namespaces is needed even in JSON data, so that the JSON procesor could correctly unmarshal JSON to XML and JAXB. 
	To make it short, the XML namespace support means, you should be able to use the very same JAXB beans for XML and JSON even if XML namespaces are involved.
	</para>
	<para>
	Namespace mapping definition is similar to <xref linkend="json.jaxb.jettison.mapped.ns.def"/> 
      <example><title>XML namespace to JSON mapping configuration for <literal>mapped</literal> notation</title>
       <programlisting linenumbering="numbered">        Map&lt;String,String&gt; ns2json = new HashMap&lt;String, String&gt;();
        ns2json.put("http://example.com", "example");
        context = new JSONJAXBContext(
	      JSONConfiguration.mapped()
	           .xml2JsonNs(ns2json).build(), types);</programlisting>
		   </example>
	</para>
      </section>
      
      
      
      
      <section>
       <title>Natural notation</title>
       
       
       <para>
       After using <literal>mapped</literal> JSON notation for a while, it was apparent, that a need to configure all the various things
       manually could be a bit problematic. To avoid the manual work, a new, <literal>natural</literal>, JSON notation was introduced in Jersey version 1.0.2.
       With <literal>natural</literal> notation, Jersey will automatically figure out how individual items need to be processed, so that you 
       do not need to do any kind of manual configuration. Java arrays and lists are mapped into JSON arrays, even for single-element cases. 
       Java numbers and booleans are correctly mapped into JSON numbers and booleans, and you do not need to bother with XML attributes,
       as in JSON, they keep the original names. So  without any additional configuration, just using
       <programlisting>JSONConfiguration.natural().build()</programlisting>
       for configuring your <code>JAXBContext</code>, you will get the following JSON for the bean 
       initialized at <xref linkend="json.jaxb.bean.init.example"/>:
       <example><title>JSON expression produced using <literal>natural</literal> notation</title>
       <programlisting linenumbering="numbered">{ "id":2
 ,"name":"Bob"
 ,"addresses":[{"street":"Long Street 1"
                     ,"town":"Short Village"}]}</programlisting>
       </example>
       You might notice, that the single element array <literal>addresses</literal> remains an array, and also the non-string <literal>id</literal>
       value is not limited with double quotes, as <literal>natural</literal> notation automatically detects these things.
       </para>
       <para>
       To support cases, when you use inheritance for your JAXB beans, an option was introduced to the <literal>natural</literal> JSON configuration builder
       to forbid XML root element stripping. The option looks pretty same as at the default <literal>mapped</literal> notation case (<xref linkend="json.jaxb.mapped.root.unwrapping"/>).
       <example id="json.jaxb.natural.root.unwrapping"><title>Keep XML root tag equivalent in JSON <literal>natural</literal> JSON notation</title>
       <programlisting>JSONConfiguration.natural().rootUnwrapping(false).build()</programlisting>
       </example>
       </para>
      </section>



      <section>
      <title>Jettison mapped notation</title>

      <para>
       Next two notations are based on project <ulink url="http://jettison.codehaus.org/User%27s+Guide">Jettison</ulink>.
       You might want to use one of these notations, when working with more complex XML documents. Namely when you deal with 
       multiple XML namespaces in your JAXB beans. 
       </para>
       <para>
       Jettison based <literal>mapped</literal> notation could be configured using:
       <programlisting>JSONConfiguration.mappedJettison().build()</programlisting>
       If nothing else is configured, you will get similar JSON output as for the default, <literal>mapped</literal>, notation:
       <example><title>JSON expression produced using Jettison based <literal>mapped</literal> notation</title>
       <programlisting linenumbering="numbered">{ "contact:{"id":2
              ,"name":"Bob"
              ,"addresses":{"street":"Long Street 1"
                                 ,"town":"Short Village"}}</programlisting>
       </example>
	The only difference is, your numbers and booleans will not be converted into strings, but you have no option for forcing arrays remain arrays
	in single-element case. Also the JSON object, representing XML root tag is being produced.
       </para>
       <para>
       If you need to deal with various XML namespaces, however, you will find Jettison <literal>mapped</literal> notation pretty useful.
       Lets define a particular namespace for <code>id</code> item:
       <programlisting>  ...
  @XmlElement(namespace="http://example.com")
  public int id;
  ...</programlisting>
 	Then you simply confgure a mapping from XML namespace into JSON prefix as follows:
      <example id="json.jaxb.jettison.mapped.ns.def"><title>XML namespace to JSON mapping configuration for Jettison based <literal>mapped</literal> notation</title>
       <programlisting linenumbering="numbered">        Map&lt;String,String&gt; ns2json = new HashMap&lt;String, String&gt;();
        ns2json.put("http://example.com", "example");
        context = new JSONJAXBContext(
	      JSONConfiguration.mappedJettison()
	           .xml2JsonNs(ns2json).build(), types);</programlisting>
       </example>
       Resulting JSON will look like in the example bellow.
        <example><title>JSON expression with XML namespaces mapped into JSON</title>
       <programlisting linenumbering="numbered">{ "contact:{"example.id":2
              ,"name":"Bob"
              ,"addresses":{"street":"Long Street 1"
                                 ,"town":"Short Village"}}</programlisting>
       </example>
       Please note, that <code>id</code> item became <code>example.id</code> based on the XML namespace mapping.
       If you have more XML namespaces in your XML, you will need to configure appropriate mapping for all of them
       </para>
      </section>



      <section>
      <title>Badgerfish notation</title>
      
      
      <para>
       Badgerfish notation is the other notation based on Jettison. From JSON and JavaScript perspective, this notation is definitely
       the worst readable one. You will probably not want to use it, unless you need to make sure your JAXB beans could be flawlessly
       written and read back to and from JSON, without bothering with any formatting configuration, namespaces, etc.
       </para>
       <para>
       <code>JSONConfiguration</code> instance using <literal>badgerfish</literal> notation could be built with
       <programlisting>JSONConfiguration.badgerFish().build()</programlisting>
       and the output JSON for <xref linkend="json.jaxb.bean.init.example"/> will be as follows.
       <example><title>JSON expression produced using <literal>badgerfish</literal> notation</title>
       <programlisting linenumbering="numbered">{"contact":{"id":{"$":"2"}
              ,"name":{"$":"Bob"}
              ,"addresses":{"street":{"$":"Long Street 1"}
                                 ,"town":{"$":"Short Village"}}}}</programlisting>
       </example>
       </para>
      </section>
      
    </section>
<section><title>Examples</title>
   <para>Download <ulink url="http://download.java.net/maven/2/com/sun/jersey/samples/json-from-jaxb/&version;/json-from-jaxb-&version;-project.zip">http://download.java.net/maven/2/com/sun/jersey/samples/json-from-jaxb/&version;/json-from-jaxb-&version;-project.zip</ulink>
   or
   <ulink url="http://download.java.net/maven/2/com/sun/jersey/samples/jmaki-backend/&version;/jmaki-backend-&version;-project.zip">http://download.java.net/maven/2/com/sun/jersey/samples/jmaki-backend/&version;/jmaki-backend-&version;-project.zip</ulink>
   to get a more complex example using JAXB based JSON support.
   </para>
   </section>
  
   </section>
  

  
   
   <section>
    <title id="json.low.level.approach.title">Low-Level JSON support</title>

    <para>Using this approach means you will be using JSONObject and/or JSONArray classes for your data representations.
    These classes are actually taken from Jettison project, but conform to the description 
    provided at <ulink url="http://www.json.org/java/index.html"> http://www.json.org/java/index.html</ulink>.
    </para>
    
    <para>
    The biggest advantage here is, that you will gain full control over the JSON format produced and consumed.
    On the other hand, dealing with your data model objects will probably be a bit more complex, than when taking the JAXB based approach.
    Differencies are depicted at the following code snipets.
    </para>
    
    <para>
    <example><title>JAXB bean creation</title>
    <programlisting>MyJaxbBean myBean = new MyJaxbBean("Agamemnon", 32);</programlisting>
    </example>
    
    Above you construct a simple JAXB bean, which could be written in JSON as <code>{"name":"Agamemnon", "age":32}</code>
    </para>
    
    <para>
    Now to build an equivalent JSONObject (in terms of resulting JSON expression), you would need several more lines of code.
    
    <example>
    <title>Constructing a JSONObject</title>
 <programlisting linenumbering="numbered">JSONObject myObject = new JSONObject();
myObject.JSONObject myObject = new JSONObject();
try {
  myObject.put("name", "Agamemnon");
  myObject.put("age", 32);
} catch (JSONException ex) {
  LOGGER.log(Level.SEVERE, "Error ...", ex);
}</programlisting>
    </example>
    </para>

    <section><title>Examples</title>

   <para>Download <ulink url="http://download.java.net/maven/2/com/sun/jersey/samples/bookmark/&version;/bookmark-&version;-project.zip">http://download.java.net/maven/2/com/sun/jersey/samples/bookmark/&version;/bookmark-&version;-project.zip</ulink> 
   to get a more complex example using low-level JSON support.
   </para>
   
  </section>
</section>
</chapter>
